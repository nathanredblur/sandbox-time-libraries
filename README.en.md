# sandbox-time-libraries

[Versión en español](README.md)

Interactive benchmark comparing **6 JavaScript libraries** for converting date strings into `Date` objects. The goal is to evaluate how well each library handles a variety of common date formats, and how much space it takes in the final bundle.

## Libraries tested

| Library | Version | Approach |
|---------|---------|----------|
| [DayJS](https://day.js.org/) | 1.11.19 | Lightweight, uses `customParseFormat` plugin with explicit format loop |
| [Chrono-node](https://github.com/wanasit/chrono) | 2.9.0 | Natural language parsing (NLP) |
| [Any-Date-Parser](https://github.com/kensnyder/any-date-parser) | 2.2.3 | Automatic format detection |
| [date-fns](https://date-fns.org/) | 4.1.0 | Modular utility functions, parsing with explicit formats |
| [Fecha](https://github.com/taylorhakes/fecha) | 4.2.3 | Micro-library for parsing and formatting |
| [Luxon](https://moment.github.io/luxon/) | 3.7.2 | Spiritual successor to Moment.js, rich API with ISO/RFC/SQL support |

## Test cases

All strings must resolve to the date **`2024-03-15`**:

| # | Format | Test string |
|---|--------|-------------|
| 1 | ISO 8601 | `2024-03-15` |
| 2 | US slash (MM/DD/YYYY) | `03/15/2024` |
| 3 | EU slash (DD/MM/YYYY) | `15/03/2024` |
| 4 | US hyphen (MM-DD-YYYY) | `03-15-2024` |
| 5 | EU hyphen (DD-MM-YYYY) | `15-03-2024` |
| 6 | US short (M/D/YYYY) | `3/15/2024` |
| 7 | EU short (D/M/YYYY) | `15/3/2024` |
| 8 | ISO slash (YYYY/MM/DD) | `2024/03/15` |
| 9 | EU dot (DD.MM.YYYY) | `15.03.2024` |
| 10 | Abbreviated month | `Mar 15, 2024` |
| 11 | Full month | `March 15, 2024` |
| 12 | Day-first abbreviated | `15 Mar 2024` |
| 13 | Day-first full | `15 March 2024` |
| 14 | Japanese | `2024年3月15日` |
| 15 | Compact | `20240315` |

## Results

Each library is tested in two modes:

- **Pure**: only uses the library's native API (format loops allowed, no custom code)
- **Custom** (\*): adds custom code (regex, value swaps, etc.) to cover missing formats

### Pure versions (library API only)

| Library | Tests | Failed formats |
|---------|:-----:|----------------|
| **DayJS** | **15/15** | — |
| Date-fns | 14/15 | Japanese |
| Luxon | 14/15 | Japanese |
| Fecha | 14/15 | Japanese |
| ChronoJS | 13/15 | Japanese, Compact |
| Any-Date | 12/15 ⚠️ | `15/03/2024`, `15-03-2024`, `15/3/2024` (confuses DD/MM with MM/DD) |

### Custom versions (\*)

| Library | Tests | Custom code added |
|---------|:-----:|-------------------|
| **ChronoJS\*** | **15/15** | Regex for Japanese and compact formats |
| **Any-Date\*** | **15/15** | Manual parsing of `/` and `-` formats (see note below) |
| **Date-fns\*** | **15/15** | Regex for Japanese format |
| **Fecha\*** | **15/15** | Regex for Japanese format |
| **Luxon\*** | **15/15** | Regex for Japanese format |

> DayJS does not need a custom version as it handles all formats natively with its `customParseFormat` plugin.

### ⚠️ Note on Any-Date-Parser

The library `any-date-parser@2.2.3` was built with `esbuild --platform=node`. Its `parser.attempt()` function returns **inconsistent results across browsers** for `/` and `-` separated formats (e.g. `MM/DD/YYYY`, `DD-MM-YYYY`):

| Environment | `parser.attempt("03/15/2024")` |
|-------------|-------------------------------|
| Node.js | `{month: 3, day: 15, year: 2024}` ✅ |
| Cursor Browser (Electron) | `{month: 3, day: 15, year: 2024}` ✅ |
| Chrome | `{year: 2024, day: 3, month: 1}` ❌ |

For this reason, the custom version (`anyDate_custom.js`) manually parses `XX/XX/YYYY` and `XX-XX-YYYY` formats without relying on the library for those patterns.

## Bundle cost (code-splitting)

Each library is loaded as a separate chunk via dynamic `import()`. The main bundle weighs only **~3.2 KB**. Each library is downloaded only when the user clicks its button.

| Chunk | Size (min) |
|-------|:----------:|
| Luxon | 82.5 KB |
| Chrono-node | 53.5 KB |
| date-fns | 45.0 KB |
| Any-Date-Parser | 18.2 KB |
| DayJS | 11.3 KB |
| Fecha | 4.3 KB |

The following image shows the treemap generated by `@parcel/reporter-bundle-analyzer` (before code-splitting), where the size of each block is proportional to its contribution to the bundle:

![Bundle analysis report](assets/report.png)

## Verdict

| | Best versatility | Smallest size |
|---|:---:|:---:|
| **Library** | **DayJS** | **Fecha** |
| Tests (pure) | 15/15 | 14/15 |
| Chunk | 11.3 KB | 4.3 KB |
| Custom needed | No | Only regex for Japanese |

**DayJS** wins on versatility: it passes all 15 tests without any custom code. Its `customParseFormat` plugin natively supports every format including Japanese (`YYYY年M月D日`) by simply adding the format to the loop. Its 11.3 KB bundle is reasonable for what it delivers.

**Fecha** is the lightest option at just 4.3 KB. It passes 14/15 tests out of the box and only needs a small regex for the Japanese format in its custom version. If bundle size is the top priority and the required formats are known, Fecha is the best choice.

The other libraries have trade-offs that make them less attractive for this use case: **Luxon** (82.5 KB) and **date-fns** (45 KB) are significantly heavier for the same result, **Chrono-node** (53.5 KB) is ideal only when NLP is needed, and **Any-Date-Parser** (18.2 KB) has a documented cross-browser bug that makes it unreliable.

## Project structure

```
src/
├── index.js            # Orchestrator: code-splitting, UI, test runner
├── testDates.js        # Test data and expected date
├── styles.css          # Styles
│
│  Pure versions (library API only + format loops)
├── day.js              # DayJS (15/15)
├── chrono.js           # Chrono-node (13/15)
├── anyDate.js          # Any-Date-Parser (12/15 ⚠️)
├── date-fns.js         # date-fns (14/15)
├── fecha.js            # Fecha (14/15)
├── luxon.js            # Luxon (14/15)
│
│  Custom versions (additional code to cover missing formats)
├── chrono_custom.js    # + Japanese and compact regex (15/15)
├── anyDate_custom.js   # + manual parsing of / and - (15/15)
├── date-fns_custom.js  # + Japanese regex (15/15)
├── fecha_custom.js     # + Japanese regex (15/15)
└── luxon_custom.js     # + Japanese regex (15/15)
```

## Running

```bash
# Install dependencies
pnpm install

# Start dev server
pnpm start

# Production build
pnpm build

# Build + bundle analysis (generates parcel-bundle-reports/default.html)
pnpm analize
```
